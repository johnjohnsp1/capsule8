// Code generated by protoc-gen-go. DO NOT EDIT.
// source: capsule8/api/v0/types.proto

/*
Package capsule8_api_v0 is a generated protocol buffer package.

It is generated from these files:
	capsule8/api/v0/types.proto
	capsule8/api/v0/event.proto
	capsule8/api/v0/telemetry_service.proto
	capsule8/api/v0/subscription.proto
	capsule8/api/v0/expression.proto

It has these top-level messages:
	IPv4Address
	IPv4AddressAndPort
	IPv6Address
	IPv6AddressAndPort
	NetworkAddress
	Event
	ChargenEvent
	TickerEvent
	ContainerEvent
	ProcessEvent
	SyscallEvent
	FileEvent
	Process
	KernelFunctionCallEvent
	NetworkEvent
	GetEventsRequest
	GetEventsResponse
	TelemetryEvent
	Subscription
	ContainerFilter
	EventFilter
	SyscallEventFilter
	ProcessEventFilter
	FileEventFilter
	KernelFunctionCallFilter
	NetworkEventFilter
	ContainerEventFilter
	ChargenEventFilter
	TickerEventFilter
	Modifier
	ThrottleModifier
	LimitModifier
	Value
	BinaryOp
	Expression
*/
package capsule8_api_v0

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Supported network address families
type NetworkAddressFamily int32

const (
	// The network address family is unknown
	NetworkAddressFamily_NETWORK_ADDRESS_FAMILY_UNKNOWN NetworkAddressFamily = 0
	// AF_INET; IPv4 address formats
	NetworkAddressFamily_NETWORK_ADDRESS_FAMILY_INET NetworkAddressFamily = 1
	// AF_INET6; IPv6 address formats
	NetworkAddressFamily_NETWORK_ADDRESS_FAMILY_INET6 NetworkAddressFamily = 2
	// AF_LOCAL / AF_UNIX; local filesystem address formats
	NetworkAddressFamily_NETWORK_ADDRESS_FAMILY_LOCAL NetworkAddressFamily = 3
)

var NetworkAddressFamily_name = map[int32]string{
	0: "NETWORK_ADDRESS_FAMILY_UNKNOWN",
	1: "NETWORK_ADDRESS_FAMILY_INET",
	2: "NETWORK_ADDRESS_FAMILY_INET6",
	3: "NETWORK_ADDRESS_FAMILY_LOCAL",
}
var NetworkAddressFamily_value = map[string]int32{
	"NETWORK_ADDRESS_FAMILY_UNKNOWN": 0,
	"NETWORK_ADDRESS_FAMILY_INET":    1,
	"NETWORK_ADDRESS_FAMILY_INET6":   2,
	"NETWORK_ADDRESS_FAMILY_LOCAL":   3,
}

func (x NetworkAddressFamily) String() string {
	return proto.EnumName(NetworkAddressFamily_name, int32(x))
}
func (NetworkAddressFamily) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// An IPv4 address
type IPv4Address struct {
	// The IPv4 address is network byte order (big endian)
	Address uint32 `protobuf:"fixed32,1,opt,name=address" json:"address,omitempty"`
}

func (m *IPv4Address) Reset()                    { *m = IPv4Address{} }
func (m *IPv4Address) String() string            { return proto.CompactTextString(m) }
func (*IPv4Address) ProtoMessage()               {}
func (*IPv4Address) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *IPv4Address) GetAddress() uint32 {
	if m != nil {
		return m.Address
	}
	return 0
}

// An IPv4 address and port
type IPv4AddressAndPort struct {
	// The IPv4 address
	Address *IPv4Address `protobuf:"bytes,1,opt,name=address" json:"address,omitempty"`
	// The port
	Port uint32 `protobuf:"varint,2,opt,name=port" json:"port,omitempty"`
}

func (m *IPv4AddressAndPort) Reset()                    { *m = IPv4AddressAndPort{} }
func (m *IPv4AddressAndPort) String() string            { return proto.CompactTextString(m) }
func (*IPv4AddressAndPort) ProtoMessage()               {}
func (*IPv4AddressAndPort) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *IPv4AddressAndPort) GetAddress() *IPv4Address {
	if m != nil {
		return m.Address
	}
	return nil
}

func (m *IPv4AddressAndPort) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

// An IPv6 address
type IPv6Address struct {
	// The high-order bytes of the IPv6 address
	High uint64 `protobuf:"fixed64,1,opt,name=high" json:"high,omitempty"`
	// The low-order bytes of the IPv6 address
	Low uint64 `protobuf:"fixed64,2,opt,name=low" json:"low,omitempty"`
}

func (m *IPv6Address) Reset()                    { *m = IPv6Address{} }
func (m *IPv6Address) String() string            { return proto.CompactTextString(m) }
func (*IPv6Address) ProtoMessage()               {}
func (*IPv6Address) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *IPv6Address) GetHigh() uint64 {
	if m != nil {
		return m.High
	}
	return 0
}

func (m *IPv6Address) GetLow() uint64 {
	if m != nil {
		return m.Low
	}
	return 0
}

// An IPv6 address and port
type IPv6AddressAndPort struct {
	// The IPv6 address
	Address *IPv6Address `protobuf:"bytes,1,opt,name=address" json:"address,omitempty"`
	// The port
	Port uint32 `protobuf:"varint,2,opt,name=port" json:"port,omitempty"`
}

func (m *IPv6AddressAndPort) Reset()                    { *m = IPv6AddressAndPort{} }
func (m *IPv6AddressAndPort) String() string            { return proto.CompactTextString(m) }
func (*IPv6AddressAndPort) ProtoMessage()               {}
func (*IPv6AddressAndPort) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *IPv6AddressAndPort) GetAddress() *IPv6Address {
	if m != nil {
		return m.Address
	}
	return nil
}

func (m *IPv6AddressAndPort) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

// A network address
type NetworkAddress struct {
	// The address family that specifies which address format is in use
	Family NetworkAddressFamily `protobuf:"varint,1,opt,name=family,enum=capsule8.api.v0.NetworkAddressFamily" json:"family,omitempty"`
	// Types that are valid to be assigned to Address:
	//	*NetworkAddress_Ipv4Address
	//	*NetworkAddress_Ipv6Address
	//	*NetworkAddress_LocalAddress
	Address isNetworkAddress_Address `protobuf_oneof:"address"`
}

func (m *NetworkAddress) Reset()                    { *m = NetworkAddress{} }
func (m *NetworkAddress) String() string            { return proto.CompactTextString(m) }
func (*NetworkAddress) ProtoMessage()               {}
func (*NetworkAddress) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

type isNetworkAddress_Address interface {
	isNetworkAddress_Address()
}

type NetworkAddress_Ipv4Address struct {
	Ipv4Address *IPv4AddressAndPort `protobuf:"bytes,10,opt,name=ipv4_address,json=ipv4Address,oneof"`
}
type NetworkAddress_Ipv6Address struct {
	Ipv6Address *IPv6AddressAndPort `protobuf:"bytes,20,opt,name=ipv6_address,json=ipv6Address,oneof"`
}
type NetworkAddress_LocalAddress struct {
	LocalAddress string `protobuf:"bytes,30,opt,name=local_address,json=localAddress,oneof"`
}

func (*NetworkAddress_Ipv4Address) isNetworkAddress_Address()  {}
func (*NetworkAddress_Ipv6Address) isNetworkAddress_Address()  {}
func (*NetworkAddress_LocalAddress) isNetworkAddress_Address() {}

func (m *NetworkAddress) GetAddress() isNetworkAddress_Address {
	if m != nil {
		return m.Address
	}
	return nil
}

func (m *NetworkAddress) GetFamily() NetworkAddressFamily {
	if m != nil {
		return m.Family
	}
	return NetworkAddressFamily_NETWORK_ADDRESS_FAMILY_UNKNOWN
}

func (m *NetworkAddress) GetIpv4Address() *IPv4AddressAndPort {
	if x, ok := m.GetAddress().(*NetworkAddress_Ipv4Address); ok {
		return x.Ipv4Address
	}
	return nil
}

func (m *NetworkAddress) GetIpv6Address() *IPv6AddressAndPort {
	if x, ok := m.GetAddress().(*NetworkAddress_Ipv6Address); ok {
		return x.Ipv6Address
	}
	return nil
}

func (m *NetworkAddress) GetLocalAddress() string {
	if x, ok := m.GetAddress().(*NetworkAddress_LocalAddress); ok {
		return x.LocalAddress
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*NetworkAddress) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _NetworkAddress_OneofMarshaler, _NetworkAddress_OneofUnmarshaler, _NetworkAddress_OneofSizer, []interface{}{
		(*NetworkAddress_Ipv4Address)(nil),
		(*NetworkAddress_Ipv6Address)(nil),
		(*NetworkAddress_LocalAddress)(nil),
	}
}

func _NetworkAddress_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*NetworkAddress)
	// address
	switch x := m.Address.(type) {
	case *NetworkAddress_Ipv4Address:
		b.EncodeVarint(10<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Ipv4Address); err != nil {
			return err
		}
	case *NetworkAddress_Ipv6Address:
		b.EncodeVarint(20<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Ipv6Address); err != nil {
			return err
		}
	case *NetworkAddress_LocalAddress:
		b.EncodeVarint(30<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.LocalAddress)
	case nil:
	default:
		return fmt.Errorf("NetworkAddress.Address has unexpected type %T", x)
	}
	return nil
}

func _NetworkAddress_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*NetworkAddress)
	switch tag {
	case 10: // address.ipv4_address
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(IPv4AddressAndPort)
		err := b.DecodeMessage(msg)
		m.Address = &NetworkAddress_Ipv4Address{msg}
		return true, err
	case 20: // address.ipv6_address
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(IPv6AddressAndPort)
		err := b.DecodeMessage(msg)
		m.Address = &NetworkAddress_Ipv6Address{msg}
		return true, err
	case 30: // address.local_address
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Address = &NetworkAddress_LocalAddress{x}
		return true, err
	default:
		return false, nil
	}
}

func _NetworkAddress_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*NetworkAddress)
	// address
	switch x := m.Address.(type) {
	case *NetworkAddress_Ipv4Address:
		s := proto.Size(x.Ipv4Address)
		n += proto.SizeVarint(10<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *NetworkAddress_Ipv6Address:
		s := proto.Size(x.Ipv6Address)
		n += proto.SizeVarint(20<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *NetworkAddress_LocalAddress:
		n += proto.SizeVarint(30<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.LocalAddress)))
		n += len(x.LocalAddress)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

func init() {
	proto.RegisterType((*IPv4Address)(nil), "capsule8.api.v0.IPv4Address")
	proto.RegisterType((*IPv4AddressAndPort)(nil), "capsule8.api.v0.IPv4AddressAndPort")
	proto.RegisterType((*IPv6Address)(nil), "capsule8.api.v0.IPv6Address")
	proto.RegisterType((*IPv6AddressAndPort)(nil), "capsule8.api.v0.IPv6AddressAndPort")
	proto.RegisterType((*NetworkAddress)(nil), "capsule8.api.v0.NetworkAddress")
	proto.RegisterEnum("capsule8.api.v0.NetworkAddressFamily", NetworkAddressFamily_name, NetworkAddressFamily_value)
}

func init() { proto.RegisterFile("capsule8/api/v0/types.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 367 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x92, 0x4f, 0x6b, 0xe2, 0x40,
	0x18, 0xc6, 0x8d, 0x2e, 0x11, 0x5f, 0xff, 0x6c, 0x18, 0x3c, 0x08, 0x8a, 0x1b, 0xb2, 0xc8, 0xca,
	0x1e, 0xa2, 0xa8, 0x84, 0x5e, 0x7a, 0x48, 0xab, 0xa2, 0x68, 0xa3, 0x8c, 0x16, 0xe9, 0x29, 0x4d,
	0x35, 0xad, 0xa1, 0x69, 0x67, 0x48, 0xd2, 0x88, 0x1f, 0xa4, 0xe7, 0x7e, 0xd5, 0xe2, 0x98, 0xa4,
	0xda, 0xaa, 0x94, 0xde, 0xde, 0x24, 0xcf, 0xf3, 0xcb, 0x6f, 0x5e, 0x06, 0x8a, 0x73, 0x83, 0xba,
	0x2f, 0xb6, 0x79, 0x56, 0x33, 0xa8, 0x55, 0xf3, 0xeb, 0x35, 0x6f, 0x4d, 0x4d, 0x57, 0xa6, 0x0e,
	0xf1, 0x08, 0xfa, 0x1d, 0x7e, 0x94, 0x0d, 0x6a, 0xc9, 0x7e, 0x5d, 0xfa, 0x07, 0xe9, 0xfe, 0xd8,
	0x6f, 0xa9, 0x8b, 0x85, 0x63, 0xba, 0x2e, 0x2a, 0x40, 0xd2, 0xd8, 0x8e, 0x05, 0x4e, 0xe4, 0xaa,
	0x49, 0x1c, 0x3e, 0x4a, 0xb7, 0x80, 0x76, 0x82, 0xea, 0xf3, 0x62, 0x4c, 0x1c, 0x0f, 0x29, 0xfb,
	0xf9, 0x74, 0xa3, 0x24, 0x7f, 0xfa, 0x83, 0xbc, 0xd3, 0x8a, 0x68, 0x08, 0xc1, 0x2f, 0x4a, 0x1c,
	0xaf, 0x10, 0x17, 0xb9, 0x6a, 0x16, 0xb3, 0x59, 0x6a, 0x32, 0x15, 0x45, 0xfd, 0x88, 0x2c, 0xad,
	0x87, 0x25, 0xe3, 0xf2, 0x98, 0xcd, 0x48, 0x80, 0x84, 0x4d, 0x56, 0xac, 0xc5, 0xe3, 0xcd, 0x18,
	0x68, 0x29, 0x3f, 0xd2, 0x52, 0xbe, 0xa5, 0xf5, 0x1a, 0x87, 0x9c, 0x66, 0x7a, 0x2b, 0xe2, 0x3c,
	0x86, 0x6a, 0xe7, 0xc0, 0xdf, 0x1b, 0x4f, 0x96, 0xbd, 0x66, 0xf4, 0x5c, 0xa3, 0xf2, 0x85, 0xbe,
	0x5f, 0xe8, 0xb2, 0x30, 0x0e, 0x4a, 0xa8, 0x07, 0x19, 0x8b, 0xfa, 0x2d, 0x3d, 0x54, 0x04, 0xa6,
	0xf8, 0xf7, 0xd4, 0xe6, 0x82, 0x83, 0xf5, 0x62, 0x38, 0xbd, 0xa9, 0x86, 0x22, 0x5b, 0x92, 0x12,
	0x91, 0xf2, 0xc7, 0x49, 0xca, 0x41, 0x52, 0xb4, 0xed, 0x0a, 0x64, 0x6d, 0x32, 0x37, 0xec, 0x08,
	0x55, 0x16, 0xb9, 0x6a, 0xaa, 0x17, 0xc3, 0x19, 0xf6, 0x3a, 0x88, 0x5d, 0xa4, 0xa2, 0xc5, 0xfe,
	0x7f, 0xe3, 0x20, 0x7f, 0xe8, 0x98, 0x48, 0x82, 0xb2, 0xd6, 0x99, 0xce, 0x46, 0x78, 0xa0, 0xab,
	0xed, 0x36, 0xee, 0x4c, 0x26, 0x7a, 0x57, 0xbd, 0xea, 0x0f, 0x6f, 0xf4, 0x6b, 0x6d, 0xa0, 0x8d,
	0x66, 0x9a, 0x10, 0x43, 0x7f, 0xa0, 0x78, 0x24, 0xd3, 0xd7, 0x3a, 0x53, 0x81, 0x43, 0x22, 0x94,
	0x4e, 0x04, 0x14, 0x21, 0x7e, 0x22, 0x31, 0x1c, 0x5d, 0xaa, 0x43, 0x21, 0x71, 0xc7, 0xb3, 0x3b,
	0xdf, 0x7c, 0x0f, 0x00, 0x00, 0xff, 0xff, 0xb5, 0x63, 0xef, 0x38, 0x12, 0x03, 0x00, 0x00,
}
